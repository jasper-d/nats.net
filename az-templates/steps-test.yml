parameters:
- name: testProject
  type: string
  values:
  - UnitTests
  - IntegrationTests
- name: mayFailOn # Agent.OS: Linux, Windows_NT, Darwin
  type: string
  default: ''
- name: preTestSteps
  type: stepList
  default: []

steps:
- checkout: none

- task: UseDotNet@2
  displayName: 'Use .NET Core sdk'
  inputs:
    packageType: sdk
    version: 3.1.403
    installationPath: $(Agent.ToolsDirectory)/dotnet

- ${{ parameters.preTestSteps }}

- task: DownloadPipelineArtifact@2
  displayName: Download ${{ parameters.testProject }} binaries
  inputs:
    targetpath: ./
    patterns: |
      src/*
      src/NATS.Client/**/*
      src/Tests/${{ parameters.testProject }}/**/*
    artifactname: binaries

- task: Powershell@2
  displayName: Set coverage collector and restore
  inputs:
    targetType: inline
    script: |
      Write-Host "msbuild version"
      dotnet msbuild -version
      Write-Host "project.assets.json"
      Get-Content src/NATS.Client/obj/project.assets.json
      Write-Host "Set variable"
      if ( -not ( "$(targetFrameworkMoniker)" -ilike "net4*" ) ) {
        echo "##vso[task.setvariable variable=collector;]XPlat Code Coverage"
      } else {
        # coverlet.collector does not support legacy net4.x
        echo "##vso[task.setvariable variable=collector;]"
      }

- task: CmdLine@2
  displayName: Restore ${{ parameters.testProject }}
  condition: and(succeeded(), ne('${{ parameters.mayFailOn }}', variables['Agent.OS']))
  inputs:
    script: >-
      dotnet restore
      src/Tests/${{ parameters.testProject }}
      --force

# We cannot set continueOnError dynamically due to Azure Devops limitations
# As a workaround, we duplicate the tasks and use a condition to switch between a version w/ and w/o continueOnError
# https://developercommunityapi.westus.cloudapp.azure.com/idea/782159/yaml-pipeline-continueonerror-cant-accept-a-variab.html
- task: CmdLine@2
  displayName: Run ${{ parameters.testProject }}
  condition: and(succeeded(), ne('${{ parameters.mayFailOn }}', variables['Agent.OS']))
  inputs:
    script: >-
      dotnet test
      src/Tests/${{ parameters.testProject }}
      --configuration Release
      --framework $(targetFrameworkMoniker)
      --logger trx
      --results-directory ./results
      --collect:"$(collector)"

- task: CmdLine@2
  displayName: Run ${{ parameters.testProject }} (continue on error)
  condition: and(succeeded(), eq('${{ parameters.mayFailOn }}', variables['Agent.OS']))
  continueOnError: true
  inputs:
    script: >-
      dotnet test
      src/Tests/${{ parameters.testProject }}
      --configuration Release
      --framework $(targetFrameworkMoniker)
      --logger trx
      --results-directory ./results
      --collect:"$(collector)"

- task: PublishTestResults@2
  displayName: Publish ${{ parameters.testProject }} results
  condition: always()
  inputs:
    testResultsFormat: VSTest
    testResultsFiles: '**/*.trx'
    testRunTitle: ${{ parameters.testProject }} $(imageName) $(targetFrameworkMoniker)

- task: PublishPipelineArtifact@1
  condition: always()
  displayName: Publish ${{ parameters.testProject }} TRX files manually
  inputs:
    targetpath: ./results
    artifactname: ${{ parameters.testProject }}-results-$(imageName)-$(targetFrameworkMoniker)

- task: Bash@3
  displayName: Publish ${{ parameters.testProject }} coverage
  condition: always()
  continueOnError: true # TODO: Fix me
  inputs:
    targetType: inline
    script: |
      cd ./results
      
      # Cleanup duplicate coverage files, https://github.com/microsoft/vstest/issues/2334
      cp $(find . -name coverage.cobertura.xml | head -1) ./coverage.cobertura.xml
      find . -name coverage.cobertura.xml -mmin +2 -exec rm -rf {} \;
      
      # Upload coverage
      bash <(curl https://codecov.io/bash) -F ${{ parameters.testProject }} -F $(Agent.OS) -F $(targetFrameworkMoniker)
